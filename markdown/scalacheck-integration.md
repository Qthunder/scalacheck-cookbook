ScalaCheck Integration
======================

<span id="_Toc300926426" class="anchor"><span id="_Toc301262007" class="anchor"><span id="_Toc308702061" class="anchor"><span id="_Toc188339623" class="anchor"></span></span></span></span>Using ScalaCheck to test Java code
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Since Java and Scala run side-by-side in the same JVM using the same bytecode, there are no special requirements to get ScalaCheck to validate existing Java code.

The set of sample code provided with this document (see References in the Appendix) contains one such example where a class encapsulating the functionality of a bank account implemented in Java is tested using property checks written in ScalaCheck. The Account class is a common example of a mutable domain object. The code used throughout the examples below can be found here: https://github.com/Accenture/scalacheck-examples/tree/master/java-scalacheck.

### <span id="_Toc308702062" class="anchor"><span id="_Toc188339624" class="anchor"></span></span>The scenario

The Java code being tested is a simple class that represents a bank account, on which deposit and withdrawal operations can be performed. The operations modify the internal state of the object. Additionally, there are methods for retrieving the balance, account age, account rate, and depositing some credit interest back into the account:

```java
public class Account {
  public final static int GOLD_AGE = 50;
  public final static double GOLD_BALANCE = 10000;
  public final static double STD_INTEREST = .02;
  public final static double GOLD_INTEREST = .03;
  private int id;
  private int age;
  private double balance;
  public Account(int id, int age, double balance) {
    // set internal attributes id, age and balance
  }
  public double getBalance() {...}
  public int getAge() {...}
  public void deposit(double amt) {
    assert (amt > 0);
    balance += amt;
  }
  public void withdraw(double amt) throws InsufficientFundsException {
    assert(amt > 0);
    if (amt <= this.balance)
    balance -= amt;
    else
    throw new InsufficientFundsException();
  }
  public double getRate() {
    if (balance < Account.GOLD_BALANCE && age < Account.GOLD_AGE)
    return(Account.STD_INTEREST);
    else
    return(Account.GOLD_INTEREST);
  }
  public void creditInterest() {
    deposit(getRate() * balance);
  }
}
```

### <span id="_Toc308702063" class="anchor"><span id="_Toc188339625" class="anchor"></span></span>The tests

The code in this section requires the Java classes to be compiled and available in the classpath, and we can let Maven take care of that. In order to run the examples below please switch to the java-scalacheck folder in the examples package, and run *mvn compile scala:console*. Please note that this example is presented as one single large specification in the example code but as smaller independent ones here, so that they can be separately tested.

Since all property checks require Account domain objects, the GenAccount singleton provides a generator for Account domain objects as well as an Arbitrary generator:

```scala
import org.scalacheck.Prop._
import org.scalacheck.{Arbitrary, Properties, Gen}
import com.company.account.Account

object GenAccount {
  import com.company.account.Account._

  val MAX_ID: Int = 999999
  val MAX_AGE: Int = 200
  val MAX_BALANCE: Double = 10 * GOLD_BALANCE

  def genAccount(maxId: Int, maxAge: Int, maxBalance: Double): Gen[Account] = for {
    id <- Gen.choose(0, maxId)
    age <- Gen.choose(0, maxAge)
    balance <- Gen.choose(0, maxBalance)
  } yield new Account(id, age, balance)

  implicit val arbAccount: Arbitrary[Account] = Arbitrary(genAccount(MAX_ID, MAX_AGE, MAX_BALANCE))
}

import GenAccount._
```

<span id="_Toc300926427" class="anchor"><span id="_Toc301262008" class="anchor"></span></span>

In the *genAccount* generator method, the choose method in the *Gen* companion object is used extensively to create random numbers. Those random numbers are used to initialize a new entity of the *Account* domain class using a *for* comprehension. Once we have got the generator in place, building an Arbitrary object is very straightforward, but please notice how in this example the values generated by the generator can be customized based on its input parameters, and how those parameters are provided to the generator when building the Arbitrary object (the generators seen previously did not use any parameters).

Property checks for the Account class are grouped into a separate *AccountSpecification* object. In this object two groups of property checks have been defined: one of the groups only uses an Account object, while the second group uses an Account object as well as a Double entity that represents an amount to deposit or withdraw.

For the first group of property checks, ScalaCheck will use the implicit arbitrary generator that we just defined. For example:

```scala
object AccountCreditCheckSpecification extends Properties("Credit interest check") {
  property("CreditInterest") = forAll { 
    acct: Account => val oldBalance = acct.getBalance()
    acct.creditInterest()
    acct.getBalance() == oldBalance + (oldBalance \* acct.getRate())
  }
}
```

For the second group of property checks, there’s a need to have a second generator that will generate random tuples of two elements of type *(Account, Double)*. The generator will use the arbitrary generator of Account objects previously defined so there is no need to duplicate any code, while the Double value will be generated using *Gen.choose*:

```scala
val genAcctAmt: Gen[(Account, Double)] = for {
  acct \<- Arbitrary.arbitrary[Account]
  amt \<- Gen.choose(0.01, MAX\_BALANCE)
} yield (acct, amt)
```

In this case there is no arbitrary generator for tuples of type (Account, Double) – even though there could be, hence we’ll need to provide an explicit reference to this generator in those property checks that require this tuple:

```scala
object AccountWithdrawalSpecification extends Properties("Withdrawal specification") {
  property("Withdraw-normal") = forAll(genAcctAmt) {
    case (acct: Account, amt: Double) => amt <= acct.getBalance() ==> {
      val oldBalance = acct.getBalance()
      acct.withdraw(amt)
      acct.getBalance() == oldBalance - amt
    }
  }
}
```

For comparison’s sake, the package with the code used throughout this document contains a version of the same property check but using an implicit object generator. The arbitrary generator as well as the modified version of the property check using the generator would look as follows:

```scala
implicit val arbAccountAmount: Arbitrary[(Account, Double)] = Arbitrary(genAcctAmt)

object AccountDepositWithArbitrary extends Properties("Account deposit") {
  property("Deposit-with-Arbitrary") = forAll { (input: (Account, Double)) => 
    input match {
      case (acct: Account, amt: Double) => val oldBalance = acct.getBalance()
      acct.deposit(amt)
      acct.getBalance() == oldBalance + amt
    }
  }
}
```

There’s very little difference between the two examples above; creating the arbitrary object once the generator function already exists is rather easy, and later the generator function is not passed as a parameter to *Prop.forAll* anymore.

The rest of the sample code contains property checks built not unlike the examples described so far, where the arbitrary generator of Account objects is used as part of property checks that validate certain functionality as in the “Rate-highbalance”, “Rate-highAge” and “CreditInterest” property checks.

The “Rate-lowBalance, lowAge” property check uses a custom generator that is scoped to remain within the boundaries of that one specific property check:

object RateLowBalanceLowAgeSpecification extends Properties("Low balance, low age spec") {

```scala
import com.company.account.Account._

property("Rate-lowBalance, lowAge") = {
  val gen = genAccount(MAX_ID, GOLD_AGE - 1, GOLD_BALANCE - .01)
  forAll(gen) {
    acct: Account => acct.getRate() == STD_INTEREST
  }
}
```

In this example, we are using the custom generator of Account objects with some very specific values, and it is kept within the local scope because it is not used in any other property check.

Since the Java code is using exceptions for handling some error scenarios, lastly the “Widthdraw-overdraft” property check uses *Prop.throws* to add a condition that validates that the code throws exceptions under certain circumstances:

```scala
import org.scalacheck.Prop

object WithdrawOverdraftSpecification extends Properties("Withdraw overdraft spec") {

  import com.company.account.InsufficientFundsException

  property("Withdraw-overdraft") = forAll(genAcctAmt) {
    case (acct: Account, amt: Double) => amt > acct.getBalance() ==> {
      val oldBalance = acct.getBalance()
      Prop.throws(acct.withdraw(amt), classOf[InsufficientFundsException]) && acct.getBalance() == oldBalance
    }
  }
}
```

The previous property check will only run when the given random amount is greater than the remaining balance in the account; if this condition is fulfilled, the code will use *Prop.throws* to ensure that the when calling the *Account.withdraw* method, an exception of type *InsufficientFundsException* is thrown every time when the amount withdrawn is greater than the current amount in the account.

<span id="_Toc308702064" class="anchor"><span id="_Toc188339626" class="anchor"></span></span>Using ScalaCheck with Scala Specs
-------------------------------------------------------------------------------------------------------------------------------

The Specs behavior-driven design library also provides integration of ScalaCheck’s properties when mixing in the *ScalaCheck* trait. The example code below can be found in the **scalacheck-integration-specs** folder.

In order to run the snippets below, switch to the scalacheck-integration-specs folder and run the following command: “sbt update compile console” (essentially, we are telling SBT to update/download the project dependencies, compile the code and start a Scala console, all in one single command).

Specs2’s *expectations* when using ScalaCheck properties are written by providing the property function to Specs’s *check* method:

```scala
import org.specs2.mutable._
import org.specs2.ScalaCheck

object SimplePropertySpec extends Specification with ScalaCheck {

  "Strings" should {
    "String.concat property" ! check { (a:String, b:String) => a.concat(b) == a + b
  }
}
```

Please note how Specs uses! (“bang”) as the operator that links Specs’s descriptions with ScalaCheck property check logic. This is specific to Specs and is part of its own domain specific language for writing test specifications.

It is possible to run Specs2 specifications from the command line but we have to use Specs2’s own runner class (we can no longer use the check method as that’s not part of Specs2’s *Specification* or *ScalaCheck* classes):

```scala
specs2.run(SimplePropertySpec)
```

Please note that if running under Windows, the console will display some gibberish where it should be displaying colours, as the Windows console is not compatible with Specs2’s ANSI colors:

```
SimplePropertySpec

Strings should
  String.concat property

Total for specification SimplePropertySpec

Finished in 34 ms

example, 100 expectations, 0 failure, 0 error

res11: Either[org.specs2.reporter.Reporter,Unit] = Right(())
```

As per Scala’s unwritten convention, returning a *Right* object means success; in case of error, the output of the execution would be a *Left* object with an error message. Please refer to Scala’s Either type for more details on Either, Left and Right.

ScalaCheck-style properties can be mixed with Specs2’s usual style of writing expectations:

```scala
import org.specs2.mutable._
import org.specs2.ScalaCheck

object SimpleMixedPropertySpec extends Specification with ScalaCheck {
  "String" should {
    "String.concat property" ! check { (a: String, b: String) =\> a.concat(b) == a + b }
    "reverse non-empty strings" ! check { (a:String) => (a.length \> 0) ==\> (a.charAt(a.length-1) == a.reverse.charAt(0)) }
  }
}
```

ScalaCheck features such as conditional properties work just fine when integrated with Specs2. Contrast this with the integration with ScalaTest below.

Generators and arbitrary generators can also be used from Specs2 expectations just like they would be used (and created) when using ”pure” ScalaCheck test cases. The Specs2 cases only need to import the implicit arbitrary object and use the check method just like before:

```scala
import org.specs2.mutable._
import org.specs2.ScalaCheck
import org.scalacheck.{Arbitrary, Properties, Gen}

case class Rectangle(val width:Double, val height:Double) {
  lazy val area = width * height
  lazy val perimeter = (2*width) + (2*height)

  def biggerThan(r:Rectangle) = (area \> r.area)
}

object RectangleGenerator {
  // same generator for the Rectangle case class as before
  val arbRectangleGen: Gen[Rectangle] = for {
    height\<- Gen.choose(0,9999)
    width\<- Gen.choose(0,9999)
  } yield(Rectangle(width, height))

  implicit val arbRectangle: Arbitrary[Rectangle] = Arbitrary(arbRectangleGen)
}

object ArbitraryRectangleSpec extends Specification with ScalaCheck {
  import RectangleGenerator._
  "Rectangle" should {
    "correctly calculate its area" ! check { (r: Rectangle) => r.area == r.width * r.height }
  }
}
```

Running this code with ```specs2.run(ArbitraryRectangleSpec)``` should report success.

<span id="_Toc300926428" class="anchor"><span id="_Toc301262009" class="anchor"><span id="_Toc308702065" class="anchor"><span id="_Toc188339627" class="anchor"></span></span></span></span>Using ScalaCheck with ScalaTest
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

ScalaTest, a popular Scala unit testing and behavior-driven design framework, offers integration with ScalaCheck for writing property style unit tests. The examples discussed below are located in folder **scalacheck-integration-scalatest**.

In order to run the snippets below, switch to the scalacheck-integration-scalatest folder and run the following command with multiple targets: “*sbt update compile console*”.

ScalaTest provides support for ScalaCheck-style specifications by mixing either the PropertySpec trait or the Checkers trait. The former allows us to write properties in ScalaTest style, while the latter allows us to do it in ScalaCheck style.

The advantage of using ScalaTest together with ScalaCheck with the PropertySpec is that ScalaTest’s matchers (MustMatchers and ShouldMatchers) can be used to validate if a property holds, which provides additional readability to the code.

The following is an example of a very simple property check written in ScalaTest using the ScalaTest style:

```scala
import org.scalatest.PropSpec
import org.scalatest.prop.{PropertyChecks, Checkers}
import org.scalatest.matchers.ShouldMatchers
import org.scalacheck.Prop._

class SimplePropertySpec extends PropSpec with PropertyChecks with ShouldMatchers {
  property("String should append each other with the concat method") {
    forAll { (a: String, b: String) => 
      a.concat(b) should be (a + b)
    }
  }
}
``` 

In order to run ScalaTest specifications from the Scala console, we can use the execute() method (with nocolor=false in Windows to avoide the pesky ANSI characters for color):

```scala
(new SimplePropertySpec).execute(color=false)
```

The output should be something like this:

```
$read$$iw$$iw$$iw$$iw$SimplePropertySpec:

- String should append each other with the concat method
```

The first line in the output looks very cryptic but it’s because of the dynamic nature of the Scala console; it will not appear like that in normal executions (e.g. when using SBT’s test action).

In the code above, ```property``` is ScalaTest’s own way to define property checks, provided by the ```PropSpec``` trait. Please note that even though it shares the name with ScalaCheck’s Properties.property method, it is **not** the same method.

Within the property block we find the ```forAll``` method (please note that this is also ScalaTest’s own ```forAll``` method, and not ScalaCheck’s). Within the ```forAll``` block we can define the logic of our property check implemented as usual as a function. As part of the property checks, the “should be” matcher has been used, which is provided by the ```ShouldMatchers``` trait (```MustMatchers``` can also be used instead). Being able to use ScalaTest’s matchers can make property checks more readable (even though this is purely a matter of taste, as it will make our property checks fully dependent on ScalaTest).

One important difference when using ```PropertyChecks``` is that some features from ScalaCheck are not available, such as the ```==\>``` function for implementing conditional properties; this method is replaced by the ```whenever``` function, as follows:

```scala
import org.scalatest.prop.{PropertyChecks, Checkers}
import org.scalatest.matchers.ShouldMatchers
import org.scalacheck.Prop._

class ReversePropertySpec extends PropSpec with PropertyChecks with ShouldMatchers {
  property("Reverse non-empty strings correctly") {
    forAll { (a: String) => 
      whenever(a.length > 0) {
        a.charAt(a.length-1) should be (a.reverse.charAt(0))
      }
    }
  }
}
```

<span id="_Toc300926429" class="anchor"><span id="_Toc301262010" class="anchor"></span></span>

When using the Checkers trait, the *check* method should be used to specific property checks. This method takes the output of ScalaCheck’s ```forAll``` function, containing the definition of a property check. The following example is the same property shown above, but now written using the ScalaCheck style with the *Checkers* trait:

```scala
import org.scalatest.prop.{PropertyChecks, Checkers}
import org.scalatest.matchers.ShouldMatchers
import org.scalacheck.Prop.\

class SimplePropertyCheckersSpec extends PropSpec with Checkers {

property("Reverse non-empty strings correctly") {

check(forAll { (a: String) =\>

(a.length \> 0) ==\> (a.charAt(a.length-1) == (a.reverse.charAt(0)))

})

}

}

For developers more familiar with the terse ScalaCheck style, this approach might be more suitable.

Lastly, ScalaTest-ScalaCheck integration also offers the possibility of using generators and Arbitrary objects:

import org.scalatest.prop.{PropertyChecks, Checkers}

import org.scalatest.matchers.ShouldMatchers

import org.scalacheck.Prop.\_

class ArbitraryRectangleWithCheckersSpec extends PropSpec with Checkers {

import com.company.scalacheck.RectangleGenerator.\_

import com.company.scalacheck.Rectangle

property("A rectangle should correctly calculate its area") {

check(forAll { (r: Rectangle) =\>

r.area == (r.width \* r.height)

})

}

property("A rectangle should be able to identify which rectangle is bigger") {

check(forAll { (r1: Rectangle, r2: Rectangle) =\>

(r1 biggerThan r2) == (r1.area \> r2.area)

})

}

}

The code of the generator has been omitted for brevity reasons since it’s the exact same code of the Rectangle class used in all the examples so far (when running this example in the Scala console, the code for the Rectangle class and its generator is being imported at the top of the specification class).

When using the Checkers style, the code shown above is not very different from pure ScalaCheck code except for the *check* method.

<span id="_Toc308702066" class="anchor"><span id="_Toc188339628" class="anchor"></span></span>Using ScalaCheck with JUnit
-------------------------------------------------------------------------------------------------------------------------

Integration between ScalaCheck and JUnit could be desirable when an existing large Java code base with JUnit tests exists and the project would like to introduce ScalaCheck and some Scala code to improve the quality of existing test code (leveraging the random data generation features of ScalaCheck).

Combined use of JUnit and ScalaCheck can be achieved in several different ways, in increasing degree of integration:

-   Call ScalaCheck properties and evaluate them using JUnit’s *assertTrue*

-   Create our own JUnit runner for “plain” ScalaCheck code; as opposed to ScalaTest and Specs, ScalaCheck does not provide a JUnit runner class even though a runner would provide the highest level of integration with JUnit. Fortunately, creating a custom JUnit runner is a fairly straightforward process.

The snippets below can be run from within the Scala console, using “*maven compile test-compile scala:console*” from the command line after switching to the **scalacheck-integration-junit** folder. Maven works on Linux, OS X and Windows, but please note that these instructions require that the “mvn” command is your PATH, which may require some configuration in your operating system.

### <span id="_Toc308702067" class="anchor"><span id="_Toc188339629" class="anchor"></span></span>Using JUnit’s assertTrue

The easiest way to integrate ScalaCheck with JUnit is to write a JUnit test suite as a Scala class in JUnit’s own style, write the ScalaCheck properties as usual and then create one or multiple JUnit tests that ensure that the property holds true using JUnit’s *assertTrue*.

Implementing the integration using this approach requires some familiarity with the ScalaCheck API and class structure.

Instead of using the *Properties.check* method to execute the property check, we need to execute the property check but collect the Boolean output (passed/not passed) so that we can provide it to JUnit’s assertTrue. For that purpose, ScalaCheck’s *check* method in the *Test* class will be used to run a given property check. The output of Test.check is of type Test.Result, and the boolean attribute Result.passed can be checked after executing the property. This is the value that will be provided to assertTrue:

import org.junit.Assert.\_

import org.junit.Test

import org.scalacheck.Test.{Params=\>TestParams}

import org.scalacheck.{ConsoleReporter, Prop, Test =\> SchkTest}

import org.scalacheck.Prop.\_

class ScalaJUnitSimpleTest {

val validProperty = Prop.forAll { (a: String) =\>

(a.length \> 0) ==\> (a + a == a.concat(a))

}

@Test def testConcat = {

assertTrue(SchkTest.check(TestParams(testCallback = ConsoleReporter()), validProperty).passed)

}

}

There is some boilerplate required to call the *Test.check* method (here renamed as *SchkTest.check* so that it doesn’t collide with JUnit’s *@Test* annotation), but it is the same for all calls to the same logic can be easily abstracted into a separate reusable method.

In order to run this code from the Scala console, the testConcat method can be called directly:

(new ScalaJUnitSimpleTest).testConcat

assertTrue does not generate any output when execution is successful , but it will throw an exception in case of failure. When these unit test suites are run from Maven or a Java development environment with a runner, the output will be slightly different.

The approach described so far is pretty straightforward for small amounts of property checks. If the number of properties is larger than a handful, there will be as many calls to assertTrue as ScalaCheck properties, which makes this approach fairly verbose.

### <span id="_Toc308702068" class="anchor"><span id="_Toc308702349" class="anchor"><span id="_Toc308702069" class="anchor"><span id="_Toc308702350" class="anchor"><span id="_Toc308702070" class="anchor"><span id="_Toc308702351" class="anchor"><span id="_Toc308702071" class="anchor"><span id="_Toc308702352" class="anchor"><span id="_Toc308702072" class="anchor"><span id="_Toc188339630" class="anchor"></span></span></span></span></span></span></span></span></span></span>Using a custom JUnit runner

Creating a custom JUnit runner is the alternative that provides the highest degree of integration between ScalaCheck and JUnit, as each one of the property checks will be transparently handled by JUnit as a separate unit test case.

When using a custom runner, the classes to be run with JUnit need to be annotated with JUnit’s @RunWith annotation, with our own JUnit-ScalaCheck runner class as a parameter. This annotation will be the only difference between these classes and plain ScalaCheck Properties classes:

<span id="_Toc300926430" class="anchor"></span>import org.scalacheck.Prop.\_

import org.junit.runner.RunWith

import com.company.scalacheck.support.ScalaCheckJUnitPropertiesRunner

import org.scalacheck.{Gen, Properties}

**@RunWith(classOf[ScalaCheckJUnitPropertiesRunner])**

class ScalaCheckRunnerTest extends Properties("Rectangle property suite") {

property("Failed test") = forAll {(a: Int) =\>

a == 1

}

property("Test with collection of data") = forAll {(a: Int) =\>

(a \> 0 && a \<= 10) ==\> collect(a) {

2 \* a == a + a

}

}

}

In the example above, the class is annotated with *com.company.scalacheck.support.ScalaCheckJUnitPropertiesRunner*, which is the custom class that takes care of providing the JUnit integration features. Describing the implementation of our custom JUnit runner class is outside of the scope of this document, but the source code is available in the source code package and is ready to be used. Additionally, there is an official version of the ScalaCheck JUnit 4 runner maintained separately, which is currently stored in the scalacheck-contrib repository in Innersource: <https://innersource.accenture.com/scalacheck/scalacheck-contrib>.

Please note that it is not easily possible to run the code above in the Scala console with the custom JUnit runner, because we would need the support of the Maven JUnit plugin to set everything up for us; it is much easier to use the traditional *Properties.check* method, which works regardless the property is annotated with @RunWith or not. In order to run the tests use command “*mvn test*” from a command window.
